<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DevCloud</title>
    <link>https://jyp-on.dev/</link>
    <description>Recent content on DevCloud</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Fri, 13 Oct 2023 02:16:00 -0600</lastBuildDate><atom:link href="https://jyp-on.dev/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux 일반 사용자 Root 권한 추가</title>
      <link>https://jyp-on.dev/posts/2023/10/linux-%EC%9D%BC%EB%B0%98-%EC%82%AC%EC%9A%A9%EC%9E%90-root-%EA%B6%8C%ED%95%9C-%EC%B6%94%EA%B0%80/</link>
      <pubDate>Fri, 13 Oct 2023 02:16:00 -0600</pubDate>
      
      <guid>https://jyp-on.dev/posts/2023/10/linux-%EC%9D%BC%EB%B0%98-%EC%82%AC%EC%9A%A9%EC%9E%90-root-%EA%B6%8C%ED%95%9C-%EC%B6%94%EA%B0%80/</guid>
      <description>본 포스팅은 Ubuntu 22.04.3 LTS 환경을 사용하고 있습니다. super user 리스트에 들어가서 다음과 같이 일반 사용자에게도 super user 권한을 등록합니다. // 꼭 sudo를 붙여줘야 수정 가능합니다. sudo vi /etc/sudoers uid, gid를 0으로 수정합니다. vi /etc/passwd root group에서 내가 사용할 사용자의 username을 적는다 vi /etc/group 여기까지 하면 jyp라는 사용자에게 root권한을 부여하는 것이 끝났습니다.
하지만 jyp를 ssh를 통해서 원격으로 접속할 시 Permission Denied가 됩니다.
SSH의 설정 파일중 default로 Root권한을 가진 사용자로는 SSH 접속을 막기 때문입니다.</description>
    </item>
    
    <item>
      <title>Docker에 nginx 컨테이너 올리기</title>
      <link>https://jyp-on.dev/posts/2023/10/docker%EC%97%90-nginx-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%98%AC%EB%A6%AC%EA%B8%B0/</link>
      <pubDate>Thu, 05 Oct 2023 02:16:00 -1200</pubDate>
      
      <guid>https://jyp-on.dev/posts/2023/10/docker%EC%97%90-nginx-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%98%AC%EB%A6%AC%EA%B8%B0/</guid>
      <description>Docker에 nginx를 올리는 방법은 다음과 같다.
// 5121 포트로 들어가면 nginx가 받아서 80포트로 넘겨준다. docker run -dit --name {name} -p 5121:80 nginx 하지만 이렇게 올리면 nginx 컨테이너의 bash로 들어가서 정적파일들을 특정 장소에 위치시켜줘야한다.
nginx 컨테이너 bash에 들어가는 방법은 다음과 같다.
docker exec -it {컨테이너이름} /bin/bash -exec는 뒤에 명령어를 실행 하는 것 or docker attach {컨테이너이름} -바로 컨테이너에 들어가는 것 -it 명령어는 컨테이너 속 터미널 입력을 할수 있도록 하는데 터미널에서 /bin/bash를 실행해서 bash shell로 들어갈수 있다.</description>
    </item>
    
    <item>
      <title>jpa error - (integer not null)</title>
      <link>https://jyp-on.dev/posts/2023/09/jpa-error-integer-not-null/</link>
      <pubDate>Thu, 21 Sep 2023 02:16:00 -0600</pubDate>
      
      <guid>https://jyp-on.dev/posts/2023/09/jpa-error-integer-not-null/</guid>
      <description>오늘 jpa entity를 설계하다가 예상치 못한 에러를 겪은 썰을 풀고자 한다..
문제의 Entity는 다음과 같다.
@Getter @Builder @AllArgsConstructor @NoArgsConstructor @Table(name = &amp;#34;reservation_time&amp;#34;) @Entity public class Time { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long tno; private LocalDate date; private int index; @JsonBackReference @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &amp;#34;mid&amp;#34;, nullable = false) private Admin admin; public void setAdmin(Admin admin) { this.admin = admin; } } 문제점을 찾았으면 이 글을 더이상 보지 않아도 된다.</description>
    </item>
    
    <item>
      <title>더티체킹이란? (dirty checking)</title>
      <link>https://jyp-on.dev/posts/2023/09/%EB%8D%94%ED%8B%B0%EC%B2%B4%ED%82%B9%EC%9D%B4%EB%9E%80-dirty-checking/</link>
      <pubDate>Wed, 20 Sep 2023 12:16:00 -0600</pubDate>
      
      <guid>https://jyp-on.dev/posts/2023/09/%EB%8D%94%ED%8B%B0%EC%B2%B4%ED%82%B9%EC%9D%B4%EB%9E%80-dirty-checking/</guid>
      <description>먼저 더티체킹이란 직역하면 더러운 것을 체크 한다는 뜻인데, 변경 감지라고 이해하면 된다.
JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초의 상태를 저장하며 이것을 스냅샷 이라고 부른다.
어떠한 방식으로 변경을 감지하는지 살펴보자. 트랜잭션을 커밋 하는시점에 엔티티 매니져 내부에서 flush가 호출된다. 엔티티와 스냅샷을 비교하여 변경된 부분을 찾는다. 변경된 부분이 있으면 수정 쿼리를 생성해 쓰기 지연 SQL 저장소에 보관한다. 쓰기 지연 저장소의 SQL을 데이터베이스에 보낸다. 데이터베이스 트랜잭션을 커밋한다. 위와 같은 flow로 진행된다.
변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용되며, 이는 즉 비영속, 준영속 처럼 영속성 컨텍스트의 관리를 받지 못하는 엔티티는 값을 변경하여도 데이터베이스에 반영이 되지 않는다.</description>
    </item>
    
    <item>
      <title>N&#43;1 문제란</title>
      <link>https://jyp-on.dev/posts/2023/09/n-1-%EB%AC%B8%EC%A0%9C%EB%9E%80/</link>
      <pubDate>Sat, 16 Sep 2023 05:10:00 -0600</pubDate>
      
      <guid>https://jyp-on.dev/posts/2023/09/n-1-%EB%AC%B8%EC%A0%9C%EB%9E%80/</guid>
      <description>N+1 문제의 예를들어 쉽게 설명 해보겠습니다.
다음과 같은 쿼리로 MEMBER 100명을 조회합니다.
SELECT * FROM MEMBER; 하지만 이 조회로 끝나는게 아니라 TEAM에 대한 조회가 필요하다면 MEMBER 조회 시 TEAM에 대한 조회도 같이 이루어집니다.
결국 100명의 회원에 대한 조회에서 회원마다의 팀 조회까지 이루어져 총 1 + N(100) = 101 번의 SQL 조회가 이루어 집니다. 그래서 저는 이 현상을 1 + N 문제라고 기억하는 편입니다.
이러한 문제를 해결하기 위해 몇 가지 방법이 있습니다.</description>
    </item>
    
    <item>
      <title>지연로딩, 즉시로딩이란?</title>
      <link>https://jyp-on.dev/posts/2023/09/%EC%A7%80%EC%97%B0%EB%A1%9C%EB%94%A9-%EC%A6%89%EC%8B%9C%EB%A1%9C%EB%94%A9%EC%9D%B4%EB%9E%80/</link>
      <pubDate>Fri, 15 Sep 2023 23:16:00 -0600</pubDate>
      
      <guid>https://jyp-on.dev/posts/2023/09/%EC%A7%80%EC%97%B0%EB%A1%9C%EB%94%A9-%EC%A6%89%EC%8B%9C%EB%A1%9C%EB%94%A9%EC%9D%B4%EB%9E%80/</guid>
      <description>Fetch Type 설명 지연로딩 (LAZY) 연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행 즉시로딩 (EAGER) 메인 객체 조회시 객체그래프를 탐색하여 연관된 객체 전부 SELECT 지연로딩을 예를 들어 Member에 직접적으로 연관된 테이블이 Team, Order이 있다고 치자.
// 첫 조회 시점에 SELECT MEMBER SQL을 날리고 Member member = jpa.find(Member.class, memberId); Team team = member.getTeam(); team.getTeamName(); // 이 시점에 SELECT TEAM SQL을 날린다. 즉시로딩 Example
// 첫 조회 시점에 SELECT MEMBER, TEAM, ORDER SQL을 날린다.</description>
    </item>
    
    <item>
      <title>Spring Boot JPQL DTO Mapping</title>
      <link>https://jyp-on.dev/posts/2023/09/spring-boot-jpql-dto-mapping/</link>
      <pubDate>Fri, 08 Sep 2023 22:16:00 -0600</pubDate>
      
      <guid>https://jyp-on.dev/posts/2023/09/spring-boot-jpql-dto-mapping/</guid>
      <description>jpa를 사용할때 jpa repository에서 return 을 DTO로 변환해서 받을 수 있다.
jpql select 부분에서 DTO로 사용할 객체를 생성 해줘야한다. 주의할 점은 DTO 생성시 패키지 초반부분부터 적어줘야 찾을 수 있다.
먼저 Person 객체와 PersonDTO 객체가 있다고 가정하자.
Person 객체에는 name, age, email, id,
PersonDTO 객체에는 name, age
이고 만약 최소 나이를 파라미터로 그 나이 이상의 Person 객체를 가져오고 싶다면 JPQL을 아래와 같이 구성 해야 한다.
@Query(value = &amp;#34;SELECT &amp;#34; + &amp;#34;new com.</description>
    </item>
    
    <item>
      <title>Spring Boot [NaverCloud ObjectStorage] 사용법</title>
      <link>https://jyp-on.dev/posts/2023/09/spring-boot-navercloud-objectstorage-%EC%82%AC%EC%9A%A9%EB%B2%95/</link>
      <pubDate>Sat, 02 Sep 2023 16:14:00 -0600</pubDate>
      
      <guid>https://jyp-on.dev/posts/2023/09/spring-boot-navercloud-objectstorage-%EC%82%AC%EC%9A%A9%EB%B2%95/</guid>
      <description>이번에 진행하는 프로젝트에서 영상 및 JSON 파일을 object storage에 저장하는 서비스 로직을 추가하게 되었다
설명에 앞서 Amazon의 S3가 아닌 Ncloud의 objectStorage를 선정한 이유는 크게 4가지다.
국내서비스라 문서읽기가 매우편함.
최근 Ncloud의 Server, DB 등등 사용해봐서 익숙함.
AWS 과금에 당한적이있음.
objectstorage 1주간 사용해봤는데 파일 크기가 얼마안되는지 아직까지 0원 청구됨. (매우쌈)
Amazon의 S3랑 완벽하게 호환되고 국내서비스라 Docs를 읽을때 좀 더 쉽게 이해할 수 있었다 나는 spring boot 즉 java 언어를 사용하기 때문에 아래와 같은 Docs를 참고하여 사용하였음</description>
    </item>
    
  </channel>
</rss>
